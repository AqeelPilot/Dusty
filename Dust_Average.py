#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Monthly dust means using user's MERRA2AODProcessor
--------------------------------------------------
1) Downloads MERRA-2 (M2T1NXAER.5.12.4) daily .nc4 via user's class
2) Converts to CSV via user's class (columns: time, latitude, longitude, dust_mass)
3) Aggregates to monthly mean per year (µg/m³) and plots all years on one chart

Example:
  python monthly_means_merra2.py \
    --start-year 2020 --end-year 2023 \
    --lat-min 30 --lat-max 75 --lon-min -15 --lon-max 60 \
    --output-dir "data/merra2" \
    --save-plot "monthly_means_2020_2023.png"

Notes:
- Requires your MERRA2AODProcessor class to be importable (same folder or on PYTHONPATH).
- Assumes CSVs generated by the class have columns: time, latitude, longitude, dust_mass
- Converts kg/m³ -> µg/m³ by ×1e9
"""

import os
import sys
import argparse
from datetime import datetime
from pathlib import Path

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm

# --- Import the user's downloader/converter class ---
try:
    from Dust_Storm_Modules import MERRA2AODProcessor  # if you kept it in its own file
except Exception:
    # If the class is in the same file "Dust_Storm_Modules.py", allow importing from there
    try:
        from Dust_Storm_Modules import MERRA2AODProcessor  # fallback import
    except Exception as e:
        print("ERROR: Could not import MERRA2AODProcessor. "
              "Place the class in 'MERRA2AODProcessor.py' or 'Dust_Storm_Modules.py' "
              "or adjust the import above.\nDetails:", e)
        sys.exit(1)


def ensure_download_and_csv(start_year: int, end_year: int,
                            lat_min: float, lat_max: float,
                            lon_min: float, lon_max: float,
                            output_dir: str):
    """Use the user's class to fetch and convert the daily files for the year range."""
    start_date = f"{start_year}-01-01"
    end_date = f"{end_year}-12-31"

    proc = MERRA2AODProcessor(
        start_date=start_date,
        end_date=end_date,
        region_bounds=(lat_min, lat_max, lon_min, lon_max),
        output_dir=output_dir
    )
    # Step 1: download (skips existing)
    proc.download_files()
    # Step 2: convert (skips existing CSVs)
    proc.convert_to_csv()


def read_monthly_means(output_dir: str,
                       start_year: int,
                       end_year: int,
                       var_col: str = "dust_mass") -> pd.DataFrame:
    """
    Read all CSVs produced by the class and compute monthly mean per year.
    Steps:
      - For each CSV day: compute spatial mean at each timestamp (if multiple hours)
      - Concatenate all timestamps
      - Convert to µg/m³
      - Group by Year, Month
    Returns tidy df: [Year, Month, mean_ugm3]
    """
    out_path = Path(output_dir)
    csv_files = sorted([p for p in out_path.glob("*.csv")
                        if p.name.startswith("MERRA2_400.tavg1_2d_aer_Nx.")])

    if not csv_files:
        print("No CSV files found in output_dir after conversion. Check paths/permissions.")
        return pd.DataFrame(columns=["Year", "Month", "mean_ugm3"])

    rows = []
    for f in tqdm(csv_files, desc="Reading daily CSVs (spatial->time means)"):
        # Filter file by year from its name, e.g., MERRA2_400.tavg1_2d_aer_Nx.YYYYMMDD.csv
        try:
            ymd = f.stem.split(".")[-1]  # 'YYYYMMDD'
            yyyy = int(ymd[:4])
        except Exception:
            # If filename pattern differs, fallback to parsing inside file
            yyyy = None

        if yyyy is not None and not (start_year <= yyyy <= end_year):
            continue

        try:
            df = pd.read_csv(f)
        except Exception as e:
            print(f"  Skipping unreadable CSV: {f.name} ({e})")
            continue

        # Validate expected columns
        if df.empty or "time" not in df.columns or var_col not in df.columns:
            continue

        # Parse time from user's formatter: "%d/%m/%Y %H:%M"
        # If parsing fails, try pandas' auto
        try:
            ts = pd.to_datetime(df["time"], format="%d/%m/%Y %H:%M", errors="coerce")
        except Exception:
            ts = pd.to_datetime(df["time"], errors="coerce")

        df = df.assign(time=ts).dropna(subset=["time"])
        if df.empty:
            continue

        # Spatial mean for each timestamp (handles multiple lat/lon cells)
        g = df.groupby("time", as_index=False)[var_col].mean()
        rows.append(g)

    if not rows:
        return pd.DataFrame(columns=["Year", "Month", "mean_ugm3"])

    all_time = pd.concat(rows, ignore_index=True)
    # Convert kg/m³ -> µg/m³
    all_time["ugm3"] = all_time[var_col] * 1e9
    all_time["Year"] = all_time["time"].dt.year
    all_time["Month"] = all_time["time"].dt.month

    monthly = (
        all_time.groupby(["Year", "Month"], as_index=False)["ugm3"]
        .mean()
        .rename(columns={"ugm3": "mean_ugm3"})
    )
    # Keep only requested year span
    monthly = monthly[(monthly["Year"] >= start_year) & (monthly["Year"] <= end_year)]
    return monthly.sort_values(["Year", "Month"])


def plot_monthly_lines(monthly_df: pd.DataFrame,
                       title: str,
                       save_plot: str | None):
    """Plot each Year as its own line across the 12 months."""
    import calendar
    if monthly_df.empty:
        print("Monthly dataframe is empty; nothing to plot.")
        return

    plt.figure(figsize=(10, 6))
    for year in sorted(monthly_df["Year"].unique()):
        sub = monthly_df[monthly_df["Year"] == year].sort_values("Month")
        plt.plot(sub["Month"], sub["mean_ugm3"], marker="o", label=str(year))

    plt.xticks(range(1, 13), [calendar.month_abbr[m] for m in range(1, 13)])
    plt.xlabel("Month")
    plt.ylabel("Dust Concentration (µg/m³)")
    plt.title(title)
    plt.grid(True, linestyle="--", alpha=0.5)
    plt.legend(title="Year", ncol=2)
    plt.tight_layout()

    if save_plot:
        Path(save_plot).parent.mkdir(parents=True, exist_ok=True)
        plt.savefig(save_plot, dpi=300)
        print(f"Saved plot -> {save_plot}")
    else:
        plt.show()


def main():
    ap = argparse.ArgumentParser(description="Monthly dust means using user's MERRA2AODProcessor")
    ap.add_argument("--start-year", type=int, required=True)
    ap.add_argument("--end-year", type=int, required=True)
    ap.add_argument("--lat-min", type=float, required=True)
    ap.add_argument("--lat-max", type=float, required=True)
    ap.add_argument("--lon-min", type=float, required=True)
    ap.add_argument("--lon-max", type=float, required=True)
    ap.add_argument("--output-dir", type=str, default="data/merra2")
    ap.add_argument("--save-plot", type=str, default=None, help="PNG path; if omitted, just shows the figure")
    ap.add_argument("--monthly-csv", type=str, default=None, help="Optional path to save monthly means CSV (pivoted)")
    args = ap.parse_args()

    # Step 1–2: Download and CSV via your class (skips existing)
    ensure_download_and_csv(
        start_year=args.start_year,
        end_year=args.end_year,
        lat_min=args.lat_min,
        lat_max=args.lat_max,
        lon_min=args.lon_min,
        lon_max=args.lon_max,
        output_dir=args.output_dir
    )

    # Step 3: Aggregate monthly
    monthly = read_monthly_means(
        output_dir=args.output_dir,
        start_year=args.start_year,
        end_year=args.end_year,
        var_col="dust_mass"
    )

    if monthly.empty:
        print("No data aggregated; aborting plot.")
        sys.exit(2)

    # Optional: save a pivot CSV for quick scanning
    if args.monthly_csv:
        pivot = monthly.pivot(index="Month", columns="Year", values="mean_ugm3").sort_index()
        Path(args.monthly_csv).parent.mkdir(parents=True, exist_ok=True)
        pivot.to_csv(args.monthly_csv, float_format="%.6f")
        print(f"Saved monthly means CSV -> {args.monthly_csv}")

    # Plot
    title = f"Monthly Mean Dust Concentration (µg/m³): {args.start_year}–{args.end_year}"
    plot_monthly_lines(monthly, title, args.save_plot)


if __name__ == "__main__":
    main()
